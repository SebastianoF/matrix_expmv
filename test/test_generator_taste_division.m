% Some tests to stress the generator of matrix divided by taste.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% test 0: to be sure we always can get a matrix for each of the first three 
% tastes.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% rng(1)

clear

sampled_tastes = zeros(1,6);

for j=1:1000
    [~, ta] = generate_rand_dA();
    sampled_tastes(ta) = sampled_tastes(ta) + 1;
end

figure(2);
bar(sampled_tastes)
set(gca,'XTickLabel',{'1', '2', '3', '4', '5'});
xlabel('tastes');
ylabel('frequency');

% It is correct if it is unbalanced with zero or almost zero elements in
% the class 4
if sampled_tastes(6) > 10
    disp('test_generator_taste_division 0a NOT passed');
else
    disp('test_generator_taste_division 0a passed');
end

% The probability of having an element of taste 1 or 2 should be almost the
% same
if abs(sampled_tastes(1) - sampled_tastes(2)) > 25
    disp('test_generator_taste_division 0b NOT passed');
else
    disp('test_generator_taste_division 0b passed');
end

% The probability of having an element of taste 4 or 5 should be almost the
% same
if abs(sampled_tastes(4) - sampled_tastes(5)) > 25
    disp('test_generator_taste_division 0c NOT passed');
else
    disp('test_generator_taste_division 0c passed');
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% test 1: to see if a matrix of a taste 1 in input_class is really of this
% taste
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear 

ta_input = 1;

dA = generate_rand_dA_by_taste(ta_input);

if taste_of_dA(dA) == ta_input
     ok = 1;
end
   
if ok == 0
    disp('test_generator_taste_division 1 NOT passed');
elseif ok == 1
    disp('test_generator_taste_division 1 passed');
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% test 2: to see if a matrix of a class 2 in ta_input is really of this
% taste
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear 

ta_input = 2;

dA = generate_rand_dA_by_taste(ta_input);

if taste_of_dA(dA) == ta_input
     ok = 1;
end
   
if ok == 0
    disp('test_generator_taste_division 2 NOT passed');
elseif ok == 1
    disp('test_generator_taste_division 2 passed');
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% test 3: to see if a matrix of a taste 3 in ta_input is really of this
% taste
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear 

ta_input = 3;

dA = generate_rand_dA_by_taste(ta_input);

if taste_of_dA(dA) == ta_input
     ok = 1;
end
   
if ok == 0
    disp('test_generator_taste_division 3 NOT passed');
elseif ok == 1
    disp('test_generator_taste_division 3 passed');
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% test 4: to see if a matrix of a taste 4 in ta_input is really of this
% taste
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear

ta_input = 4;

dA = generate_rand_dA_by_taste(ta_input);

if taste_of_dA(dA) == ta_input
     ok = 1;
end
   
if ok == 0
    disp('test_generator_taste_division 4 NOT passed');
elseif ok == 1
    disp('test_generator_taste_division 4 passed');
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% test 5: to see if a matrix of a taste 5 in ta_input is really of this
% taste
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear

ta_input = 5;

dA = generate_rand_dA_by_taste(ta_input);

if taste_of_dA(dA) == ta_input
     ok = 1;
end
   
if ok == 0
    disp('test_generator_taste_division 5 NOT passed');
elseif ok == 1
    disp('test_generator_taste_division 5 passed');
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% test 6: to see if a matrix of a taste 6 in ta_input is really of this
% taste
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear

ta_input = 6;

dA = generate_rand_dA_by_taste(ta_input);

if taste_of_dA(dA) == ta_input
     ok = 1;
end
   
if ok == 0
    disp('test_generator_taste_division 6 NOT passed');
elseif ok == 1
    disp('test_generator_taste_division 6 passed');
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% test 7: visual assesment of the tangent vector field generated by
% each class.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear 

% vector fields
dA_1 = generate_rand_dA_by_taste(1);
dA_2 = generate_rand_dA_by_taste(2);
dA_3 = generate_rand_dA_by_taste(3);
dA_4 = generate_rand_dA_by_taste(4);
dA_5 = generate_rand_dA_by_taste(5);
dA_6 = generate_rand_dA_by_taste(6);

ax = int16([-10,10,-10,10]);

[dX,dY] = meshgrid(ax(1):ax(2), ax(3):ax(4));

dU1 = dA_1(1, 1)*dX + dA_1(1, 2)*dY;
dV1 = dA_1(2, 1)*dX + dA_1(2, 2)*dY;

dU2 = dA_2(1, 1)*dX + dA_2(1, 2)*dY;
dV2 = dA_2(2, 1)*dX + dA_2(2, 2)*dY;

dU3 = dA_3(1, 1)*dX + dA_3(1, 2)*dY;
dV3 = dA_3(2, 1)*dX + dA_3(2, 2)*dY;

dU4 = dA_4(1, 1)*dX + dA_4(1, 2)*dY;
dV4 = dA_4(2, 1)*dX + dA_4(2, 2)*dY;

dU5 = dA_5(1, 1)*dX + dA_5(1, 2)*dY;
dV5 = dA_5(2, 1)*dX + dA_5(2, 2)*dY;

dU6 = dA_6(1, 1)*dX + dA_6(1, 2)*dY;
dV6 = dA_6(2, 1)*dX + dA_6(2, 2)*dY;

% integral curves:
times = 0:0.1:5;

num_time_points = size(times, 2);
x_0 = 2;
y_0 = 2;

curve_1 = zeros(3,num_time_points);
curve_2 = zeros(3,num_time_points);
curve_3 = zeros(3,num_time_points);
curve_4 = zeros(3,num_time_points);
curve_5 = zeros(3,num_time_points);
curve_6 = zeros(3,num_time_points);

for t = 1:num_time_points
    curve_1(:, t) = expm(times(t) * dA_1) * [x_0; y_0; 0];
    curve_2(:, t) = expm(times(t) * dA_2) * [x_0; y_0; 0];
    curve_3(:, t) = expm(times(t) * dA_3) * [x_0; y_0; 0];
    curve_4(:, t) = expm(times(t) * dA_4) * [x_0; y_0; 0];
    curve_5(:, t) = expm(times(t) * dA_5) * [x_0; y_0; 0];
    curve_6(:, t) = expm(times(t) * dA_6) * [x_0; y_0; 0];
end

figure('units','normalized','position',[.1 .1 .7 .7]);
subplot(231)
quiver(dX,dY,dU1,dV1)
hold on
plot(curve_1(1, :), curve_1(2, :))
axis(ax)
title('taste 1: unstable node')
hold off

subplot(232)
quiver(dX,dY,dU2,dV2)
hold on
plot(curve_2(1, :), curve_2(2, :))
axis(ax)
title('taste 2: stable node')
hold off

subplot(233)
quiver(dX,dY,dU3,dV3)
hold on
plot(curve_3(1, :), curve_3(2, :))
axis(ax)
title('taste 3: saddle')
hold off

subplot(234)
quiver(dX,dY,dU4,dV4)
hold on
plot(curve_4(1, :), curve_4(2, :))
axis(ax)
title('taste 4: unstable spiral')
hold off

subplot(235)
quiver(dX,dY,dU5,dV5)
hold on
plot(curve_5(1, :), curve_5(2, :))
axis(ax)
title('taste 5: stable spiral')
hold off

subplot(236)
quiver(dX,dY,dU6,dV6)
hold on
plot(curve_6(1, :), curve_6(2, :))
axis(ax)
title('taste 6: circle')
hold off

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% test 8: test generate_dA_balanced
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear all

outcome_taste = zeros(1,6);
for i=1:1000
    [~,ta] = generate_rand_dA_balanced(); 
    ta = int16(ta);
    outcome_taste(1,ta) = outcome_taste(1,ta) + 1;
end

%disp(beans)

figure(3);
bar(outcome_taste)
set(gca,'XTickLabel',{'1', '2', '3', '4', '5', '6'});
xlabel('Tastes');
ylabel('sampling frequency');

% this should provide a histogram with all of the values almost at the same
% heigth.
if max(outcome_taste) - min(outcome_taste) > 50
    disp('test_generator_taste_division 8 NOT passed');
else
    disp('test_generator_taste_division 8 passed');
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% test 9a: taste for n dimensional matrices
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear

dA = generate_rand_dA_by_taste_n_dim(20, 'pos');

if all(eig(dA) > 0)
    disp('test_generator_taste_division 9a passed');
else
    disp('test_generator_taste_division NOT 9a passed');
end

% test 9b: taste for n dimensional matrices

dA = generate_rand_dA_by_taste_n_dim(20, 'neg');

if all(eig(dA) < 0)
    disp('test_generator_taste_division 9b passed');
else
    disp('test_generator_taste_division NOT 9b passed');
end

% test 9c: taste for n dimensional matrices

dA = generate_rand_dA_by_taste_n_dim(20, 'mix');

if all(eig(dA) < 0) == 0 && all(eig(dA) > 0) == 0
    disp('test_generator_taste_division 9c passed');
else
    disp('test_generator_taste_division NOT 9c passed');
end


clear

